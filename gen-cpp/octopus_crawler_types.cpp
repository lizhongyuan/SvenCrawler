/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "octopus_crawler_types.h"

#include <algorithm>



int _kTemplateTypeValues[] = {
  TemplateType::CSS_SELECTOR_TYPE,
  TemplateType::PLAIN_HTML_TYPE,
  TemplateType::RELAY_TYPE,
  TemplateType::TEMPLATE_TYPE_MAX,
  TemplateType::NONE_TYPE
};
const char* _kTemplateTypeNames[] = {
  "CSS_SELECTOR_TYPE",
  "PLAIN_HTML_TYPE",
  "RELAY_TYPE",
  "TEMPLATE_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _TemplateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTemplateTypeValues, _kTemplateTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHeaderFieldsTypeValues[] = {
  HeaderFieldsType::DEFAULT_TYPE,
  HeaderFieldsType::UPDATE_PART_TYPE,
  HeaderFieldsType::UPDATE_ALL_TYPE,
  HeaderFieldsType::HEADER_FIELDS_TYPE_MAX,
  HeaderFieldsType::NONE_TYPE
};
const char* _kHeaderFieldsTypeNames[] = {
  "DEFAULT_TYPE",
  "UPDATE_PART_TYPE",
  "UPDATE_ALL_TYPE",
  "HEADER_FIELDS_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _HeaderFieldsType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHeaderFieldsTypeValues, _kHeaderFieldsTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDownloaderTypeValues[] = {
  DownloaderType::NORMAL_TYPE,
  DownloaderType::WEBKIT_TYPE,
  DownloaderType::DOWNLOADER_TYPE_MAX,
  DownloaderType::NONE_TYPE
};
const char* _kDownloaderTypeNames[] = {
  "NORMAL_TYPE",
  "WEBKIT_TYPE",
  "DOWNLOADER_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _DownloaderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDownloaderTypeValues, _kDownloaderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kResultTypeValues[] = {
  ResultType::LINK_TYPE,
  ResultType::REPORT_TYPE,
  ResultType::DATA_TYPE,
  ResultType::RESULT_TYPE_MAX,
  ResultType::NONE_TYPE
};
const char* _kResultTypeNames[] = {
  "LINK_TYPE",
  "REPORT_TYPE",
  "DATA_TYPE",
  "RESULT_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _ResultType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kResultTypeValues, _kResultTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskErrorTypeValues[] = {
  TaskErrorType::OK_TYPE,
  TaskErrorType::DOWNLOAD_FAILED_TYPE,
  TaskErrorType::EXTRACT_FAILED_TYPE,
  TaskErrorType::BANNED_TYPE,
  TaskErrorType::TASK_ERROR_TYPE_MAX,
  TaskErrorType::NONE_TYPE
};
const char* _kTaskErrorTypeNames[] = {
  "OK_TYPE",
  "DOWNLOAD_FAILED_TYPE",
  "EXTRACT_FAILED_TYPE",
  "BANNED_TYPE",
  "TASK_ERROR_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _TaskErrorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTaskErrorTypeValues, _kTaskErrorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kUrlTypeValues[] = {
  UrlType::LINK_URL_TYPE,
  UrlType::POST_URL_TYPE,
  UrlType::IMG_URL_TYPE,
  UrlType::PHONE_IMG_URL_TYPE,
  UrlType::NEXT_PAGE_URL_TYPE,
  UrlType::URL_TYPE_MAX,
  UrlType::NONE_TYPE
};
const char* _kUrlTypeNames[] = {
  "LINK_URL_TYPE",
  "POST_URL_TYPE",
  "IMG_URL_TYPE",
  "PHONE_IMG_URL_TYPE",
  "NEXT_PAGE_URL_TYPE",
  "URL_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _UrlType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kUrlTypeValues, _kUrlTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kUpdateTaskTypesValues[] = {
  UpdateTaskTypes::KCRAWLERBOT,
  UpdateTaskTypes::KSEOBOT,
  UpdateTaskTypes::KTEMPALTE,
  UpdateTaskTypes::KDIAL
};
const char* _kUpdateTaskTypesNames[] = {
  "KCRAWLERBOT",
  "KSEOBOT",
  "KTEMPALTE",
  "KDIAL"
};
const std::map<int, const char*> _UpdateTaskTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kUpdateTaskTypesValues, _kUpdateTaskTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBotTasktypesValues[] = {
  BotTasktypes::KCRAWLERTASK,
  BotTasktypes::KSEOTASK,
  BotTasktypes::KCRAWLERTEMPLATEUPDATE,
  BotTasktypes::KBOTUPDATE,
  BotTasktypes::KDIALTASK
};
const char* _kBotTasktypesNames[] = {
  "KCRAWLERTASK",
  "KSEOTASK",
  "KCRAWLERTEMPLATEUPDATE",
  "KBOTUPDATE",
  "KDIALTASK"
};
const std::map<int, const char*> _BotTasktypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kBotTasktypesValues, _kBotTasktypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* DownloadReqItem::ascii_fingerprint = "66121B4576FE7A9DA35B400A9B046C57";
const uint8_t DownloadReqItem::binary_fingerprint[16] = {0x66,0x12,0x1B,0x45,0x76,0xFE,0x7A,0x9D,0xA3,0x5B,0x40,0x0A,0x9B,0x04,0x6C,0x57};

uint32_t DownloadReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->referer);
          this->__isset.referer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ua);
          this->__isset.ua = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->header_fields_type = (HeaderFieldsType::type)ecast0;
          this->__isset.header_fields_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->downloader_type = (DownloaderType::type)ecast1;
          this->__isset.downloader_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_fields);
          this->__isset.post_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_out);
          this->__isset.time_out = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->header_list.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->header_list.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->header_list[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.header_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadReqItem");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("referer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->referer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ua", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ua);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header_fields_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->header_fields_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downloader_type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->downloader_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_fields", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->post_fields);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_out", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->time_out);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header_list", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->header_list.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->header_list.begin(); _iter7 != this->header_list.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadReqItem &a, DownloadReqItem &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.ip, b.ip);
  swap(a.referer, b.referer);
  swap(a.ua, b.ua);
  swap(a.header_fields_type, b.header_fields_type);
  swap(a.downloader_type, b.downloader_type);
  swap(a.post_fields, b.post_fields);
  swap(a.time_out, b.time_out);
  swap(a.header_list, b.header_list);
  swap(a.__isset, b.__isset);
}

const char* DownloadPropItem::ascii_fingerprint = "6AD589019BA4210C43B7F2ACD5B79431";
const uint8_t DownloadPropItem::binary_fingerprint[16] = {0x6A,0xD5,0x89,0x01,0x9B,0xA4,0x21,0x0C,0x43,0xB7,0xF2,0xAC,0xD5,0xB7,0x94,0x31};

uint32_t DownloadPropItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_friendly);
          this->__isset.is_friendly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retry_times);
          this->__isset.retry_times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth);
          this->__isset.depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->store_extract_depth);
          this->__isset.store_extract_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->url_type = (UrlType::type)ecast8;
          this->__isset.url_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->template_type = (TemplateType::type)ecast9;
          this->__isset.template_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->seed_url);
          this->__isset.seed_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url_template);
          this->__isset.url_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadPropItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadPropItem");

  xfer += oprot->writeFieldBegin("is_friendly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_friendly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->interval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retry_times", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->retry_times);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("store_extract_depth", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->store_extract_depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->url_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("template_type", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->template_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seed_url", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->seed_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_template", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->url_template);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadPropItem &a, DownloadPropItem &b) {
  using ::std::swap;
  swap(a.is_friendly, b.is_friendly);
  swap(a.interval, b.interval);
  swap(a.retry_times, b.retry_times);
  swap(a.task_id, b.task_id);
  swap(a.depth, b.depth);
  swap(a.store_extract_depth, b.store_extract_depth);
  swap(a.url_type, b.url_type);
  swap(a.template_type, b.template_type);
  swap(a.seed_url, b.seed_url);
  swap(a.url_template, b.url_template);
  swap(a.__isset, b.__isset);
}

const char* DownloadResultItem::ascii_fingerprint = "C217E1C050106CFEC86D19C280538EDC";
const uint8_t DownloadResultItem::binary_fingerprint[16] = {0xC2,0x17,0xE1,0xC0,0x50,0x10,0x6C,0xFE,0xC8,0x6D,0x19,0xC2,0x80,0x53,0x8E,0xDC};

uint32_t DownloadResultItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->is_ok = (TaskErrorType::type)ecast10;
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->http_code);
          this->__isset.http_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->err_info);
          this->__isset.err_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->result_type = (ResultType::type)ecast11;
          this->__isset.result_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extract_map.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              std::vector<std::string> & _val18 = this->extract_map[_key17];
              {
                _val18.clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _etype22;
                xfer += iprot->readListBegin(_etype22, _size19);
                _val18.resize(_size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  xfer += iprot->readString(_val18[_i23]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extract_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadResultItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadResultItem");

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("http_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->http_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err_info", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->err_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->result_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extract_map", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->extract_map.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter24;
    for (_iter24 = this->extract_map.begin(); _iter24 != this->extract_map.end(); ++_iter24)
    {
      xfer += oprot->writeString(_iter24->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter24->second.size()));
        std::vector<std::string> ::const_iterator _iter25;
        for (_iter25 = _iter24->second.begin(); _iter25 != _iter24->second.end(); ++_iter25)
        {
          xfer += oprot->writeString((*_iter25));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadResultItem &a, DownloadResultItem &b) {
  using ::std::swap;
  swap(a.is_ok, b.is_ok);
  swap(a.http_code, b.http_code);
  swap(a.err_info, b.err_info);
  swap(a.result_type, b.result_type);
  swap(a.extract_map, b.extract_map);
  swap(a.__isset, b.__isset);
}

const char* DownloadTask::ascii_fingerprint = "518A291C1954A5A1A154D5C54CF3974E";
const uint8_t DownloadTask::binary_fingerprint[16] = {0x51,0x8A,0x29,0x1C,0x19,0x54,0xA5,0xA1,0xA1,0x54,0xD5,0xC5,0x4C,0xF3,0x97,0x4E};

uint32_t DownloadTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->prop_item.read(iprot);
          this->__isset.prop_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_item.read(iprot);
          this->__isset.result_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prop_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->prop_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_item", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->result_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadTask &a, DownloadTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.prop_item, b.prop_item);
  swap(a.result_item, b.result_item);
  swap(a.__isset, b.__isset);
}

const char* ListDownloadTask::ascii_fingerprint = "4D2F16D6A536B351AB93CF80029B5BFA";
const uint8_t ListDownloadTask::binary_fingerprint[16] = {0x4D,0x2F,0x16,0xD6,0xA5,0x36,0xB3,0x51,0xAB,0x93,0xCF,0x80,0x02,0x9B,0x5B,0xFA};

uint32_t ListDownloadTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_down_task.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->list_down_task.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->list_down_task[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.list_down_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDownloadTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ListDownloadTask");

  xfer += oprot->writeFieldBegin("list_down_task", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->list_down_task.size()));
    std::vector<DownloadTask> ::const_iterator _iter31;
    for (_iter31 = this->list_down_task.begin(); _iter31 != this->list_down_task.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDownloadTask &a, ListDownloadTask &b) {
  using ::std::swap;
  swap(a.list_down_task, b.list_down_task);
  swap(a.__isset, b.__isset);
}

const char* ExtractItem::ascii_fingerprint = "BB887B606A671A3339D7E22993AF3EA5";
const uint8_t ExtractItem::binary_fingerprint[16] = {0xBB,0x88,0x7B,0x60,0x6A,0x67,0x1A,0x33,0x39,0xD7,0xE2,0x29,0x93,0xAF,0x3E,0xA5};

uint32_t ExtractItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task.read(iprot);
          this->__isset.task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExtractItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ExtractItem");

  xfer += oprot->writeFieldBegin("task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExtractItem &a, ExtractItem &b) {
  using ::std::swap;
  swap(a.task, b.task);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

const char* ExtractItems::ascii_fingerprint = "92B6DF721AAFD189D4D0E6350420465D";
const uint8_t ExtractItems::binary_fingerprint[16] = {0x92,0xB6,0xDF,0x72,0x1A,0xAF,0xD1,0x89,0xD4,0xD0,0xE6,0x35,0x04,0x20,0x46,0x5D};

uint32_t ExtractItems::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->extract_task_list.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->extract_task_list.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->extract_task_list[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.extract_task_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExtractItems::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ExtractItems");

  xfer += oprot->writeFieldBegin("extract_task_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->extract_task_list.size()));
    std::vector<ExtractItem> ::const_iterator _iter37;
    for (_iter37 = this->extract_task_list.begin(); _iter37 != this->extract_task_list.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExtractItems &a, ExtractItems &b) {
  using ::std::swap;
  swap(a.extract_task_list, b.extract_task_list);
  swap(a.__isset, b.__isset);
}

const char* MatchedResultItem::ascii_fingerprint = "7609B1D31BB860963FAAAD9401CD61DA";
const uint8_t MatchedResultItem::binary_fingerprint[16] = {0x76,0x09,0xB1,0xD3,0x1B,0xB8,0x60,0x96,0x3F,0xAA,0xAD,0x94,0x01,0xCD,0x61,0xDA};

uint32_t MatchedResultItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->self_result.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _ktype39;
            ::apache::thrift::protocol::TType _vtype40;
            xfer += iprot->readMapBegin(_ktype39, _vtype40, _size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              std::string _key43;
              xfer += iprot->readString(_key43);
              std::vector<std::string> & _val44 = this->self_result[_key43];
              {
                _val44.clear();
                uint32_t _size45;
                ::apache::thrift::protocol::TType _etype48;
                xfer += iprot->readListBegin(_etype48, _size45);
                _val44.resize(_size45);
                uint32_t _i49;
                for (_i49 = 0; _i49 < _size45; ++_i49)
                {
                  xfer += iprot->readString(_val44[_i49]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.self_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sub_result_list.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->sub_result_list.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              {
                this->sub_result_list[_i54].clear();
                uint32_t _size55;
                ::apache::thrift::protocol::TType _ktype56;
                ::apache::thrift::protocol::TType _vtype57;
                xfer += iprot->readMapBegin(_ktype56, _vtype57, _size55);
                uint32_t _i59;
                for (_i59 = 0; _i59 < _size55; ++_i59)
                {
                  std::string _key60;
                  xfer += iprot->readString(_key60);
                  std::vector<std::string> & _val61 = this->sub_result_list[_i54][_key60];
                  {
                    _val61.clear();
                    uint32_t _size62;
                    ::apache::thrift::protocol::TType _etype65;
                    xfer += iprot->readListBegin(_etype65, _size62);
                    _val61.resize(_size62);
                    uint32_t _i66;
                    for (_i66 = 0; _i66 < _size62; ++_i66)
                    {
                      xfer += iprot->readString(_val61[_i66]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sub_result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ok);
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->err_info);
          this->__isset.err_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchedResultItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MatchedResultItem");

  xfer += oprot->writeFieldBegin("self_result", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->self_result.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter67;
    for (_iter67 = this->self_result.begin(); _iter67 != this->self_result.end(); ++_iter67)
    {
      xfer += oprot->writeString(_iter67->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter67->second.size()));
        std::vector<std::string> ::const_iterator _iter68;
        for (_iter68 = _iter67->second.begin(); _iter68 != _iter67->second.end(); ++_iter68)
        {
          xfer += oprot->writeString((*_iter68));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_result_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->sub_result_list.size()));
    std::vector<std::map<std::string, std::vector<std::string> > > ::const_iterator _iter69;
    for (_iter69 = this->sub_result_list.begin(); _iter69 != this->sub_result_list.end(); ++_iter69)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter69).size()));
        std::map<std::string, std::vector<std::string> > ::const_iterator _iter70;
        for (_iter70 = (*_iter69).begin(); _iter70 != (*_iter69).end(); ++_iter70)
        {
          xfer += oprot->writeString(_iter70->first);
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter70->second.size()));
            std::vector<std::string> ::const_iterator _iter71;
            for (_iter71 = _iter70->second.begin(); _iter71 != _iter70->second.end(); ++_iter71)
            {
              xfer += oprot->writeString((*_iter71));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err_info", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->err_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchedResultItem &a, MatchedResultItem &b) {
  using ::std::swap;
  swap(a.self_result, b.self_result);
  swap(a.sub_result_list, b.sub_result_list);
  swap(a.is_ok, b.is_ok);
  swap(a.err_info, b.err_info);
  swap(a.__isset, b.__isset);
}

const char* DownloadedBodyItem::ascii_fingerprint = "9580C4A6AB1BE3F9451F3A7393FB5DAD";
const uint8_t DownloadedBodyItem::binary_fingerprint[16] = {0x95,0x80,0xC4,0xA6,0xAB,0x1B,0xE3,0xF9,0x45,0x1F,0x3A,0x73,0x93,0xFB,0x5D,0xAD};

uint32_t DownloadedBodyItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task.read(iprot);
          this->__isset.task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ok);
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadedBodyItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadedBodyItem");

  xfer += oprot->writeFieldBegin("task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadedBodyItem &a, DownloadedBodyItem &b) {
  using ::std::swap;
  swap(a.task, b.task);
  swap(a.is_ok, b.is_ok);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

const char* DialInfoItem::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t DialInfoItem::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t DialInfoItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pwd);
          this->__isset.pwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialInfoItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DialInfoItem");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pwd", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialInfoItem &a, DialInfoItem &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.pwd, b.pwd);
  swap(a.__isset, b.__isset);
}

const char* DialRespItem::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t DialRespItem::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t DialRespItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialRespItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DialRespItem");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialRespItem &a, DialRespItem &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

const char* UpdateReqItem::ascii_fingerprint = "F4F95FBAFCD0D6402E66FF49B8F546CD";
const uint8_t UpdateReqItem::binary_fingerprint[16] = {0xF4,0xF9,0x5F,0xBA,0xFC,0xD0,0xD6,0x40,0x2E,0x66,0xFF,0x49,0xB8,0xF5,0x46,0xCD};

uint32_t UpdateReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_ip);
          this->__isset.target_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          this->update_type = (UpdateTaskTypes::type)ecast72;
          this->__isset.update_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_name);
          this->__isset.target_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->template_type = (TemplateType::type)ecast73;
          this->__isset.template_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dial_info.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->dial_info.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readString(this->dial_info[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dial_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateReqItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->target_ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->update_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->target_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("template_type", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32((int32_t)this->template_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dial_info", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dial_info.size()));
    std::vector<std::string> ::const_iterator _iter79;
    for (_iter79 = this->dial_info.begin(); _iter79 != this->dial_info.end(); ++_iter79)
    {
      xfer += oprot->writeString((*_iter79));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateReqItem &a, UpdateReqItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.url, b.url);
  swap(a.target_ip, b.target_ip);
  swap(a.node_id, b.node_id);
  swap(a.timestamp, b.timestamp);
  swap(a.version, b.version);
  swap(a.update_type, b.update_type);
  swap(a.target_name, b.target_name);
  swap(a.template_type, b.template_type);
  swap(a.dial_info, b.dial_info);
  swap(a.__isset, b.__isset);
}

const char* UpdateRespItem::ascii_fingerprint = "44C8C8DCDECB6662B8DB5787B65D5E80";
const uint8_t UpdateRespItem::binary_fingerprint[16] = {0x44,0xC8,0xC8,0xDC,0xDE,0xCB,0x66,0x62,0xB8,0xDB,0x57,0x87,0xB6,0x5D,0x5E,0x80};

uint32_t UpdateRespItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_version);
          this->__isset.server_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_version);
          this->__isset.client_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version_name);
          this->__isset.version_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dial_resp.clear();
            uint32_t _size80;
            ::apache::thrift::protocol::TType _etype83;
            xfer += iprot->readListBegin(_etype83, _size80);
            this->dial_resp.resize(_size80);
            uint32_t _i84;
            for (_i84 = 0; _i84 < _size80; ++_i84)
            {
              xfer += this->dial_resp[_i84].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dial_resp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateRespItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateRespItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->server_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("client_version", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->client_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->version_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dial_resp", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dial_resp.size()));
    std::vector<DialRespItem> ::const_iterator _iter85;
    for (_iter85 = this->dial_resp.begin(); _iter85 != this->dial_resp.end(); ++_iter85)
    {
      xfer += (*_iter85).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateRespItem &a, UpdateRespItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.node_id, b.node_id);
  swap(a.server_version, b.server_version);
  swap(a.client_version, b.client_version);
  swap(a.version_name, b.version_name);
  swap(a.timestamp, b.timestamp);
  swap(a.body, b.body);
  swap(a.dial_resp, b.dial_resp);
  swap(a.__isset, b.__isset);
}

const char* UpdateTask::ascii_fingerprint = "5302C3A69502391998AF50922BD603B6";
const uint8_t UpdateTask::binary_fingerprint[16] = {0x53,0x02,0xC3,0xA6,0x95,0x02,0x39,0x19,0x98,0xAF,0x50,0x92,0x2B,0xD6,0x03,0xB6};

uint32_t UpdateTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resp_item.read(iprot);
          this->__isset.resp_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resp_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resp_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateTask &a, UpdateTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.resp_item, b.resp_item);
  swap(a.__isset, b.__isset);
}

const char* DedupExistItem::ascii_fingerprint = "1767FFB0CB3D9275BC64B198AB3B8A8B";
const uint8_t DedupExistItem::binary_fingerprint[16] = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

uint32_t DedupExistItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_exists);
          this->__isset.is_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->item_info);
          this->__isset.item_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DedupExistItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DedupExistItem");

  xfer += oprot->writeFieldBegin("is_exists", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_info", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->item_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DedupExistItem &a, DedupExistItem &b) {
  using ::std::swap;
  swap(a.is_exists, b.is_exists);
  swap(a.item_info, b.item_info);
  swap(a.__isset, b.__isset);
}

const char* SimulatorReqItem::ascii_fingerprint = "3DEA490DCFDBF7F9065EFB84569A610F";
const uint8_t SimulatorReqItem::binary_fingerprint[16] = {0x3D,0xEA,0x49,0x0D,0xCF,0xDB,0xF7,0xF9,0x06,0x5E,0xFB,0x84,0x56,0x9A,0x61,0x0F};

uint32_t SimulatorReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_words);
          this->__isset.key_words = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url_regex);
          this->__isset.url_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->click_count);
          this->__isset.click_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->city);
          this->__isset.city = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorReqItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_words", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->key_words);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_regex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url_regex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->click_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("city", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->city);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorReqItem &a, SimulatorReqItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.key_words, b.key_words);
  swap(a.url_regex, b.url_regex);
  swap(a.click_count, b.click_count);
  swap(a.city, b.city);
  swap(a.__isset, b.__isset);
}

const char* SimulatorRespItem::ascii_fingerprint = "511023597CEDC78D170D0E3534ED6749";
const uint8_t SimulatorRespItem::binary_fingerprint[16] = {0x51,0x10,0x23,0x59,0x7C,0xED,0xC7,0x8D,0x17,0x0D,0x0E,0x35,0x34,0xED,0x67,0x49};

uint32_t SimulatorRespItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_url);
          this->__isset.target_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookie);
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorRespItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorRespItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->target_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->cookie);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorRespItem &a, SimulatorRespItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.target_url, b.target_url);
  swap(a.ip, b.ip);
  swap(a.cookie, b.cookie);
  swap(a.node_id, b.node_id);
  swap(a.time_stamp, b.time_stamp);
  swap(a.__isset, b.__isset);
}

const char* SimulatorTask::ascii_fingerprint = "6DDAC11E7F4D257B9656E37EA715A996";
const uint8_t SimulatorTask::binary_fingerprint[16] = {0x6D,0xDA,0xC1,0x1E,0x7F,0x4D,0x25,0x7B,0x96,0x56,0xE3,0x7E,0xA7,0x15,0xA9,0x96};

uint32_t SimulatorTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resp_item.read(iprot);
          this->__isset.resp_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resp_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resp_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorTask &a, SimulatorTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.resp_item, b.resp_item);
  swap(a.__isset, b.__isset);
}

const char* PcNode::ascii_fingerprint = "5959CE085787E3D819EB3EB041545A2C";
const uint8_t PcNode::binary_fingerprint[16] = {0x59,0x59,0xCE,0x08,0x57,0x87,0xE3,0xD8,0x19,0xEB,0x3E,0xB0,0x41,0x54,0x5A,0x2C};

uint32_t PcNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret);
          this->__isset.secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PcNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PcNode");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->secret);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PcNode &a, PcNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.name, b.name);
  swap(a.time_stamp, b.time_stamp);
  swap(a.secret, b.secret);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

const char* BotMessage::ascii_fingerprint = "C7A4EEC2526E0BDEE5C75B1D2196BEFC";
const uint8_t BotMessage::binary_fingerprint[16] = {0xC7,0xA4,0xEE,0xC2,0x52,0x6E,0x0B,0xDE,0xE5,0xC7,0x5B,0x1D,0x21,0x96,0xBE,0xFC};

uint32_t BotMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->down_load_task.read(iprot);
          this->__isset.down_load_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->simulator_task.read(iprot);
          this->__isset.simulator_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_task.read(iprot);
          this->__isset.update_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast86;
          xfer += iprot->readI32(ecast86);
          this->bot_task_types = (BotTasktypes::type)ecast86;
          this->__isset.bot_task_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BotMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BotMessage");

  xfer += oprot->writeFieldBegin("down_load_task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->down_load_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simulator_task", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->simulator_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_task", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->update_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bot_task_types", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->bot_task_types);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BotMessage &a, BotMessage &b) {
  using ::std::swap;
  swap(a.down_load_task, b.down_load_task);
  swap(a.simulator_task, b.simulator_task);
  swap(a.update_task, b.update_task);
  swap(a.bot_task_types, b.bot_task_types);
  swap(a.token, b.token);
  swap(a.__isset, b.__isset);
}

const char* NodeState::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t NodeState::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t NodeState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cpu_state);
          this->__isset.cpu_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mem_state);
          this->__isset.mem_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NodeState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NodeState");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cpu_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_state", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->mem_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NodeState &a, NodeState &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.cpu_state, b.cpu_state);
  swap(a.mem_state, b.mem_state);
  swap(a.__isset, b.__isset);
}


