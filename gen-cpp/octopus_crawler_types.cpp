/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "octopus_crawler_types.h"

#include <algorithm>



int _kTemplateTypeValues[] = {
  TemplateType::CSS_SELECTOR_TYPE,
  TemplateType::PLAIN_HTML_TYPE,
  TemplateType::RELAY_TYPE,
  TemplateType::TEMPLATE_TYPE_MAX,
  TemplateType::NONE_TYPE
};
const char* _kTemplateTypeNames[] = {
  "CSS_SELECTOR_TYPE",
  "PLAIN_HTML_TYPE",
  "RELAY_TYPE",
  "TEMPLATE_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _TemplateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTemplateTypeValues, _kTemplateTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHeaderFieldsTypeValues[] = {
  HeaderFieldsType::DEFAULT_TYPE,
  HeaderFieldsType::UPDATE_PART_TYPE,
  HeaderFieldsType::UPDATE_ALL_TYPE,
  HeaderFieldsType::HEADER_FIELDS_TYPE_MAX,
  HeaderFieldsType::NONE_TYPE
};
const char* _kHeaderFieldsTypeNames[] = {
  "DEFAULT_TYPE",
  "UPDATE_PART_TYPE",
  "UPDATE_ALL_TYPE",
  "HEADER_FIELDS_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _HeaderFieldsType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kHeaderFieldsTypeValues, _kHeaderFieldsTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDownloaderTypeValues[] = {
  DownloaderType::NORMAL_TYPE,
  DownloaderType::WEBKIT_TYPE,
  DownloaderType::DOWNLOADER_TYPE_MAX,
  DownloaderType::NONE_TYPE
};
const char* _kDownloaderTypeNames[] = {
  "NORMAL_TYPE",
  "WEBKIT_TYPE",
  "DOWNLOADER_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _DownloaderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDownloaderTypeValues, _kDownloaderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kResultTypeValues[] = {
  ResultType::LINK_TYPE,
  ResultType::REPORT_TYPE,
  ResultType::DATA_TYPE,
  ResultType::RESULT_TYPE_MAX,
  ResultType::NONE_TYPE
};
const char* _kResultTypeNames[] = {
  "LINK_TYPE",
  "REPORT_TYPE",
  "DATA_TYPE",
  "RESULT_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _ResultType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kResultTypeValues, _kResultTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskErrorTypeValues[] = {
  TaskErrorType::OK_TYPE,
  TaskErrorType::DOWNLOAD_FAILED_TYPE,
  TaskErrorType::EXTRACT_FAILED_TYPE,
  TaskErrorType::BANNED_TYPE,
  TaskErrorType::TASK_ERROR_TYPE_MAX,
  TaskErrorType::NONE_TYPE
};
const char* _kTaskErrorTypeNames[] = {
  "OK_TYPE",
  "DOWNLOAD_FAILED_TYPE",
  "EXTRACT_FAILED_TYPE",
  "BANNED_TYPE",
  "TASK_ERROR_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _TaskErrorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTaskErrorTypeValues, _kTaskErrorTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kUrlTypeValues[] = {
  UrlType::LINK_URL_TYPE,
  UrlType::POST_URL_TYPE,
  UrlType::IMG_URL_TYPE,
  UrlType::PHONE_IMG_URL_TYPE,
  UrlType::NEXT_PAGE_URL_TYPE,
  UrlType::URL_TYPE_MAX,
  UrlType::NONE_TYPE
};
const char* _kUrlTypeNames[] = {
  "LINK_URL_TYPE",
  "POST_URL_TYPE",
  "IMG_URL_TYPE",
  "PHONE_IMG_URL_TYPE",
  "NEXT_PAGE_URL_TYPE",
  "URL_TYPE_MAX",
  "NONE_TYPE"
};
const std::map<int, const char*> _UrlType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kUrlTypeValues, _kUrlTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBotTasktypesValues[] = {
  BotTasktypes::KCRAWLERTASK,
  BotTasktypes::KCRAWLERTEMPLATEUPDATE,
  BotTasktypes::KBOTUPDATE,
  BotTasktypes::KSEOTASK
};
const char* _kBotTasktypesNames[] = {
  "KCRAWLERTASK",
  "KCRAWLERTEMPLATEUPDATE",
  "KBOTUPDATE",
  "KSEOTASK"
};
const std::map<int, const char*> _BotTasktypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kBotTasktypesValues, _kBotTasktypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* DownloadReqItem::ascii_fingerprint = "66121B4576FE7A9DA35B400A9B046C57";
const uint8_t DownloadReqItem::binary_fingerprint[16] = {0x66,0x12,0x1B,0x45,0x76,0xFE,0x7A,0x9D,0xA3,0x5B,0x40,0x0A,0x9B,0x04,0x6C,0x57};

uint32_t DownloadReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->referer);
          this->__isset.referer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ua);
          this->__isset.ua = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->header_fields_type = (HeaderFieldsType::type)ecast0;
          this->__isset.header_fields_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->downloader_type = (DownloaderType::type)ecast1;
          this->__isset.downloader_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_fields);
          this->__isset.post_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->time_out);
          this->__isset.time_out = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->header_list.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->header_list.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->header_list[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.header_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadReqItem");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("referer", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->referer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ua", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->ua);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header_fields_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->header_fields_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downloader_type", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->downloader_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_fields", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->post_fields);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_out", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->time_out);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("header_list", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->header_list.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->header_list.begin(); _iter7 != this->header_list.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadReqItem &a, DownloadReqItem &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.ip, b.ip);
  swap(a.referer, b.referer);
  swap(a.ua, b.ua);
  swap(a.header_fields_type, b.header_fields_type);
  swap(a.downloader_type, b.downloader_type);
  swap(a.post_fields, b.post_fields);
  swap(a.time_out, b.time_out);
  swap(a.header_list, b.header_list);
  swap(a.__isset, b.__isset);
}

const char* DownloadPropItem::ascii_fingerprint = "6AD589019BA4210C43B7F2ACD5B79431";
const uint8_t DownloadPropItem::binary_fingerprint[16] = {0x6A,0xD5,0x89,0x01,0x9B,0xA4,0x21,0x0C,0x43,0xB7,0xF2,0xAC,0xD5,0xB7,0x94,0x31};

uint32_t DownloadPropItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_friendly);
          this->__isset.is_friendly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retry_times);
          this->__isset.retry_times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth);
          this->__isset.depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->store_extract_depth);
          this->__isset.store_extract_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->url_type = (UrlType::type)ecast8;
          this->__isset.url_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->template_type = (TemplateType::type)ecast9;
          this->__isset.template_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->seed_url);
          this->__isset.seed_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url_template);
          this->__isset.url_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadPropItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadPropItem");

  xfer += oprot->writeFieldBegin("is_friendly", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_friendly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->interval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retry_times", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->retry_times);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("store_extract_depth", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->store_extract_depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->url_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("template_type", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->template_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seed_url", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->seed_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_template", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->url_template);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadPropItem &a, DownloadPropItem &b) {
  using ::std::swap;
  swap(a.is_friendly, b.is_friendly);
  swap(a.interval, b.interval);
  swap(a.retry_times, b.retry_times);
  swap(a.task_id, b.task_id);
  swap(a.depth, b.depth);
  swap(a.store_extract_depth, b.store_extract_depth);
  swap(a.url_type, b.url_type);
  swap(a.template_type, b.template_type);
  swap(a.seed_url, b.seed_url);
  swap(a.url_template, b.url_template);
  swap(a.__isset, b.__isset);
}

const char* DownloadResultItem::ascii_fingerprint = "C217E1C050106CFEC86D19C280538EDC";
const uint8_t DownloadResultItem::binary_fingerprint[16] = {0xC2,0x17,0xE1,0xC0,0x50,0x10,0x6C,0xFE,0xC8,0x6D,0x19,0xC2,0x80,0x53,0x8E,0xDC};

uint32_t DownloadResultItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->is_ok = (TaskErrorType::type)ecast10;
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->http_code);
          this->__isset.http_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->err_info);
          this->__isset.err_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->result_type = (ResultType::type)ecast11;
          this->__isset.result_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->extract_map.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              std::vector<std::string> & _val18 = this->extract_map[_key17];
              {
                _val18.clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _etype22;
                xfer += iprot->readListBegin(_etype22, _size19);
                _val18.resize(_size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  xfer += iprot->readString(_val18[_i23]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.extract_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadResultItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadResultItem");

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("http_code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->http_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err_info", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->err_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->result_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extract_map", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->extract_map.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter24;
    for (_iter24 = this->extract_map.begin(); _iter24 != this->extract_map.end(); ++_iter24)
    {
      xfer += oprot->writeString(_iter24->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter24->second.size()));
        std::vector<std::string> ::const_iterator _iter25;
        for (_iter25 = _iter24->second.begin(); _iter25 != _iter24->second.end(); ++_iter25)
        {
          xfer += oprot->writeString((*_iter25));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadResultItem &a, DownloadResultItem &b) {
  using ::std::swap;
  swap(a.is_ok, b.is_ok);
  swap(a.http_code, b.http_code);
  swap(a.err_info, b.err_info);
  swap(a.result_type, b.result_type);
  swap(a.extract_map, b.extract_map);
  swap(a.__isset, b.__isset);
}

const char* DownloadTask::ascii_fingerprint = "518A291C1954A5A1A154D5C54CF3974E";
const uint8_t DownloadTask::binary_fingerprint[16] = {0x51,0x8A,0x29,0x1C,0x19,0x54,0xA5,0xA1,0xA1,0x54,0xD5,0xC5,0x4C,0xF3,0x97,0x4E};

uint32_t DownloadTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->prop_item.read(iprot);
          this->__isset.prop_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_item.read(iprot);
          this->__isset.result_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prop_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->prop_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_item", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->result_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadTask &a, DownloadTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.prop_item, b.prop_item);
  swap(a.result_item, b.result_item);
  swap(a.__isset, b.__isset);
}

const char* ListDownloadTask::ascii_fingerprint = "4D2F16D6A536B351AB93CF80029B5BFA";
const uint8_t ListDownloadTask::binary_fingerprint[16] = {0x4D,0x2F,0x16,0xD6,0xA5,0x36,0xB3,0x51,0xAB,0x93,0xCF,0x80,0x02,0x9B,0x5B,0xFA};

uint32_t ListDownloadTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_down_task.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->list_down_task.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->list_down_task[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.list_down_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDownloadTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ListDownloadTask");

  xfer += oprot->writeFieldBegin("list_down_task", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->list_down_task.size()));
    std::vector<DownloadTask> ::const_iterator _iter31;
    for (_iter31 = this->list_down_task.begin(); _iter31 != this->list_down_task.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDownloadTask &a, ListDownloadTask &b) {
  using ::std::swap;
  swap(a.list_down_task, b.list_down_task);
  swap(a.__isset, b.__isset);
}

const char* ExtractItem::ascii_fingerprint = "BB887B606A671A3339D7E22993AF3EA5";
const uint8_t ExtractItem::binary_fingerprint[16] = {0xBB,0x88,0x7B,0x60,0x6A,0x67,0x1A,0x33,0x39,0xD7,0xE2,0x29,0x93,0xAF,0x3E,0xA5};

uint32_t ExtractItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task.read(iprot);
          this->__isset.task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExtractItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ExtractItem");

  xfer += oprot->writeFieldBegin("task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExtractItem &a, ExtractItem &b) {
  using ::std::swap;
  swap(a.task, b.task);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

const char* MatchedResultItem::ascii_fingerprint = "7609B1D31BB860963FAAAD9401CD61DA";
const uint8_t MatchedResultItem::binary_fingerprint[16] = {0x76,0x09,0xB1,0xD3,0x1B,0xB8,0x60,0x96,0x3F,0xAA,0xAD,0x94,0x01,0xCD,0x61,0xDA};

uint32_t MatchedResultItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->self_result.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              std::string _key37;
              xfer += iprot->readString(_key37);
              std::vector<std::string> & _val38 = this->self_result[_key37];
              {
                _val38.clear();
                uint32_t _size39;
                ::apache::thrift::protocol::TType _etype42;
                xfer += iprot->readListBegin(_etype42, _size39);
                _val38.resize(_size39);
                uint32_t _i43;
                for (_i43 = 0; _i43 < _size39; ++_i43)
                {
                  xfer += iprot->readString(_val38[_i43]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.self_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sub_result_list.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->sub_result_list.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              {
                this->sub_result_list[_i48].clear();
                uint32_t _size49;
                ::apache::thrift::protocol::TType _ktype50;
                ::apache::thrift::protocol::TType _vtype51;
                xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
                uint32_t _i53;
                for (_i53 = 0; _i53 < _size49; ++_i53)
                {
                  std::string _key54;
                  xfer += iprot->readString(_key54);
                  std::vector<std::string> & _val55 = this->sub_result_list[_i48][_key54];
                  {
                    _val55.clear();
                    uint32_t _size56;
                    ::apache::thrift::protocol::TType _etype59;
                    xfer += iprot->readListBegin(_etype59, _size56);
                    _val55.resize(_size56);
                    uint32_t _i60;
                    for (_i60 = 0; _i60 < _size56; ++_i60)
                    {
                      xfer += iprot->readString(_val55[_i60]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sub_result_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ok);
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->err_info);
          this->__isset.err_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchedResultItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MatchedResultItem");

  xfer += oprot->writeFieldBegin("self_result", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->self_result.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter61;
    for (_iter61 = this->self_result.begin(); _iter61 != this->self_result.end(); ++_iter61)
    {
      xfer += oprot->writeString(_iter61->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter61->second.size()));
        std::vector<std::string> ::const_iterator _iter62;
        for (_iter62 = _iter61->second.begin(); _iter62 != _iter61->second.end(); ++_iter62)
        {
          xfer += oprot->writeString((*_iter62));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sub_result_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->sub_result_list.size()));
    std::vector<std::map<std::string, std::vector<std::string> > > ::const_iterator _iter63;
    for (_iter63 = this->sub_result_list.begin(); _iter63 != this->sub_result_list.end(); ++_iter63)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter63).size()));
        std::map<std::string, std::vector<std::string> > ::const_iterator _iter64;
        for (_iter64 = (*_iter63).begin(); _iter64 != (*_iter63).end(); ++_iter64)
        {
          xfer += oprot->writeString(_iter64->first);
          {
            xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter64->second.size()));
            std::vector<std::string> ::const_iterator _iter65;
            for (_iter65 = _iter64->second.begin(); _iter65 != _iter64->second.end(); ++_iter65)
            {
              xfer += oprot->writeString((*_iter65));
            }
            xfer += oprot->writeListEnd();
          }
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err_info", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->err_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchedResultItem &a, MatchedResultItem &b) {
  using ::std::swap;
  swap(a.self_result, b.self_result);
  swap(a.sub_result_list, b.sub_result_list);
  swap(a.is_ok, b.is_ok);
  swap(a.err_info, b.err_info);
  swap(a.__isset, b.__isset);
}

const char* DownloadedBodyItem::ascii_fingerprint = "9580C4A6AB1BE3F9451F3A7393FB5DAD";
const uint8_t DownloadedBodyItem::binary_fingerprint[16] = {0x95,0x80,0xC4,0xA6,0xAB,0x1B,0xE3,0xF9,0x45,0x1F,0x3A,0x73,0x93,0xFB,0x5D,0xAD};

uint32_t DownloadedBodyItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->task.read(iprot);
          this->__isset.task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ok);
          this->__isset.is_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->body);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DownloadedBodyItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DownloadedBodyItem");

  xfer += oprot->writeFieldBegin("task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ok", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_ok);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->body);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DownloadedBodyItem &a, DownloadedBodyItem &b) {
  using ::std::swap;
  swap(a.task, b.task);
  swap(a.is_ok, b.is_ok);
  swap(a.body, b.body);
  swap(a.__isset, b.__isset);
}

const char* DedupExistItem::ascii_fingerprint = "1767FFB0CB3D9275BC64B198AB3B8A8B";
const uint8_t DedupExistItem::binary_fingerprint[16] = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

uint32_t DedupExistItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_exists);
          this->__isset.is_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->item_info);
          this->__isset.item_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DedupExistItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DedupExistItem");

  xfer += oprot->writeFieldBegin("is_exists", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item_info", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->item_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DedupExistItem &a, DedupExistItem &b) {
  using ::std::swap;
  swap(a.is_exists, b.is_exists);
  swap(a.item_info, b.item_info);
  swap(a.__isset, b.__isset);
}

const char* SimulatorReqItem::ascii_fingerprint = "3DEA490DCFDBF7F9065EFB84569A610F";
const uint8_t SimulatorReqItem::binary_fingerprint[16] = {0x3D,0xEA,0x49,0x0D,0xCF,0xDB,0xF7,0xF9,0x06,0x5E,0xFB,0x84,0x56,0x9A,0x61,0x0F};

uint32_t SimulatorReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_words);
          this->__isset.key_words = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url_regex);
          this->__isset.url_regex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->click_count);
          this->__isset.click_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->city);
          this->__isset.city = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorReqItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_words", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->key_words);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url_regex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->url_regex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("click_count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->click_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("city", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->city);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorReqItem &a, SimulatorReqItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.key_words, b.key_words);
  swap(a.url_regex, b.url_regex);
  swap(a.click_count, b.click_count);
  swap(a.city, b.city);
  swap(a.__isset, b.__isset);
}

const char* SimulatorRespItem::ascii_fingerprint = "511023597CEDC78D170D0E3534ED6749";
const uint8_t SimulatorRespItem::binary_fingerprint[16] = {0x51,0x10,0x23,0x59,0x7C,0xED,0xC7,0x8D,0x17,0x0D,0x0E,0x35,0x34,0xED,0x67,0x49};

uint32_t SimulatorRespItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_url);
          this->__isset.target_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookie);
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorRespItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorRespItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->target_url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->cookie);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorRespItem &a, SimulatorRespItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.target_url, b.target_url);
  swap(a.ip, b.ip);
  swap(a.cookie, b.cookie);
  swap(a.node_id, b.node_id);
  swap(a.time_stamp, b.time_stamp);
  swap(a.__isset, b.__isset);
}

const char* SimulatorTask::ascii_fingerprint = "6DDAC11E7F4D257B9656E37EA715A996";
const uint8_t SimulatorTask::binary_fingerprint[16] = {0x6D,0xDA,0xC1,0x1E,0x7F,0x4D,0x25,0x7B,0x96,0x56,0xE3,0x7E,0xA7,0x15,0xA9,0x96};

uint32_t SimulatorTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resp_item.read(iprot);
          this->__isset.resp_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SimulatorTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SimulatorTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resp_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resp_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SimulatorTask &a, SimulatorTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.resp_item, b.resp_item);
  swap(a.__isset, b.__isset);
}

const char* UpdateReqItem::ascii_fingerprint = "3DEA490DCFDBF7F9065EFB84569A610F";
const uint8_t UpdateReqItem::binary_fingerprint[16] = {0x3D,0xEA,0x49,0x0D,0xCF,0xDB,0xF7,0xF9,0x06,0x5E,0xFB,0x84,0x56,0x9A,0x61,0x0F};

uint32_t UpdateReqItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateReqItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateReqItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateReqItem &a, UpdateReqItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.url, b.url);
  swap(a.node_id, b.node_id);
  swap(a.timestamp, b.timestamp);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

const char* UpdateRespItem::ascii_fingerprint = "C4A8A7FE71C2DB9CB73D92862AA4C591";
const uint8_t UpdateRespItem::binary_fingerprint[16] = {0xC4,0xA8,0xA7,0xFE,0x71,0xC2,0xDB,0x9C,0xB7,0x3D,0x92,0x86,0x2A,0xA4,0xC5,0x91};

uint32_t UpdateRespItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_id);
          this->__isset.task_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateRespItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateRespItem");

  xfer += oprot->writeFieldBegin("task_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateRespItem &a, UpdateRespItem &b) {
  using ::std::swap;
  swap(a.task_id, b.task_id);
  swap(a.node_id, b.node_id);
  swap(a.version, b.version);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

const char* PcNode::ascii_fingerprint = "5959CE085787E3D819EB3EB041545A2C";
const uint8_t PcNode::binary_fingerprint[16] = {0x59,0x59,0xCE,0x08,0x57,0x87,0xE3,0xD8,0x19,0xEB,0x3E,0xB0,0x41,0x54,0x5A,0x2C};

uint32_t PcNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time_stamp);
          this->__isset.time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret);
          this->__isset.secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PcNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PcNode");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time_stamp", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->time_stamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->secret);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PcNode &a, PcNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.name, b.name);
  swap(a.time_stamp, b.time_stamp);
  swap(a.secret, b.secret);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

const char* UpdateTask::ascii_fingerprint = "80C2F8269D96B440D367475AC0BB2A8D";
const uint8_t UpdateTask::binary_fingerprint[16] = {0x80,0xC2,0xF8,0x26,0x9D,0x96,0xB4,0x40,0xD3,0x67,0x47,0x5A,0xC0,0xBB,0x2A,0x8D};

uint32_t UpdateTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->req_item.read(iprot);
          this->__isset.req_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resp_item.read(iprot);
          this->__isset.resp_item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateTask");

  xfer += oprot->writeFieldBegin("req_item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->req_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resp_item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->resp_item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateTask &a, UpdateTask &b) {
  using ::std::swap;
  swap(a.req_item, b.req_item);
  swap(a.resp_item, b.resp_item);
  swap(a.__isset, b.__isset);
}

const char* BotMessage::ascii_fingerprint = "C80ED6AC6ED2EA757A14ED64AAE77DFA";
const uint8_t BotMessage::binary_fingerprint[16] = {0xC8,0x0E,0xD6,0xAC,0x6E,0xD2,0xEA,0x75,0x7A,0x14,0xED,0x64,0xAA,0xE7,0x7D,0xFA};

uint32_t BotMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->down_load_task.read(iprot);
          this->__isset.down_load_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->simulator_task.read(iprot);
          this->__isset.simulator_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_task.read(iprot);
          this->__isset.update_task = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->bot_task_types = (BotTasktypes::type)ecast66;
          this->__isset.bot_task_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BotMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BotMessage");

  xfer += oprot->writeFieldBegin("down_load_task", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->down_load_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("simulator_task", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->simulator_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_task", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->update_task.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bot_task_types", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->bot_task_types);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BotMessage &a, BotMessage &b) {
  using ::std::swap;
  swap(a.down_load_task, b.down_load_task);
  swap(a.simulator_task, b.simulator_task);
  swap(a.update_task, b.update_task);
  swap(a.bot_task_types, b.bot_task_types);
  swap(a.token, b.token);
  swap(a.__isset, b.__isset);
}

const char* NodeState::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t NodeState::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t NodeState::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cpu_state);
          this->__isset.cpu_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mem_state);
          this->__isset.mem_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NodeState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NodeState");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_state", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cpu_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_state", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->mem_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NodeState &a, NodeState &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.cpu_state, b.cpu_state);
  swap(a.mem_state, b.mem_state);
  swap(a.__isset, b.__isset);
}


